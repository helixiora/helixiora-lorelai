# Flask Application Guidelines

## 1. Project Structure

- Use a modular project structure with clear separation of concerns
- Follow the application factory pattern
- Entry point is `run.py` with factory in `project_root/app/factory.py`
- Organize code into blueprints for scalability and maintainability
- Use environment variables for configuration (stored in `.env`)

### Recommended Directory Layout

project_root/
├── app/ # Main application package
│ ├── templates/ # Jinja2 templates
│ ├── static/ # Static files (CSS, JS, images)
│ │ ├── css/
│ │ ├── js/
│ │ └── img/
│ ├── helpers/ # Helper functions and utilities
│ ├── routes/ # Blueprint routes
│ ├── routes/api/v1/ # API routes
│ ├── models.py # SQLAlchemy models
│ ├── factory.py # App factory
├── migrations/ # Database migrations
├── tests/ # Test suite
├── docs/ # Documentation
├── .env # Environment variables
├── .env.example # Example environment variables
├── .gitignore # Git ignore rules
├── .pre-commit-config.yaml # Pre-commit hooks
├── readme.md # Project documentation
├── pyproject.toml # Project configuration
├── Dockerfile # Docker configuration
├── docker-compose.yml # Docker compose configuration
├── config.py # Project configuration
├── requirements.txt # Project dependencies
└── run.py # Application entry point

## 2. Code Organization

- Use blueprints for feature-based code organization
- routes that don't return a page or reroute the user should be in the api/v1/ folder and use flask_restx to define the routes
- routes that return a page should be in the routes/ folder and use flask_login to define the routes
- Implement clear configuration management
- Follow PEP 8 style guidelines

## 3. Security Best Practices

- Store secrets in environment variables
- Use secure password hashing
- Implement proper session management
- Sanitize all user inputs

## 4. Database Guidelines

- Use SQLAlchemy for database operations
- Implement database migrations
- Follow proper session management
- Use appropriate indexing strategies

## 5. Testing Requirements

- Write unit tests for all features
- Maintain separate test configurations
- Use pytest as testing framework
- Aim for high test coverage

## 6. Deployment Considerations

- Use production-grade WSGI server
- Implement proper logging
- Configure error handling
- Set up monitoring
- Use SSL/TLS in production

## 7. Documentation

- Document API endpoints
- Maintain requirements.txt
- Include setup instructions
- Document configuration options

## 8. Frontend-backend communication

- Use cookies for authentication
- Use CSRF tokens for security
- Use JWT for authentication
- When the frontend needs to make a request to the backend, it should use the makeAuthenticatedRequest function in the utils.js file.
- The makeAuthenticatedRequest function will add the access token to the request headers and include the CSRF token in the request headers if the request is not a GET request.
- The makeAuthenticatedRequest function will include the cookies in the request if the request is not a GET request.


  You are an expert in Python, Flask, and scalable API development.

  Key Principles
  - Write concise, technical responses with accurate Python examples.
  - Prefer iteration and modularization over code duplication.
  - Use descriptive variable names with auxiliary verbs (e.g., is_active, has_permission).
  - Use lowercase with underscores for directories and files (e.g., blueprints/user_routes.py).
  - Favor named exports for routes and utility functions.
  - Use the Receive an Object, Return an Object (RORO) pattern where applicable.

  Python/Flask
  - Use def for function definitions.
  - Use type hints for all function signatures where possible.
  - File structure: Flask app initialization, blueprints, models, utilities, config.
  - Avoid unnecessary curly braces in conditional statements.
  - For single-line statements in conditionals, omit curly braces.
  - Use concise, one-line syntax for simple conditional statements (e.g., if condition: do_something()).

  Error Handling and Validation
  - Prioritize error handling and edge cases:
    - Handle errors and edge cases at the beginning of functions.
    - Use early returns for error conditions to avoid deeply nested if statements.
    - Place the happy path last in the function for improved readability.
    - Avoid unnecessary else statements; use the if-return pattern instead.
    - Use guard clauses to handle preconditions and invalid states early.
    - Implement proper error logging and user-friendly error messages.
    - Use custom error types or error factories for consistent error handling.

  Dependencies
  - Flask
  - Flask-RESTX (for RESTful API development)
  - Flask-SQLAlchemy (for ORM)
  - Flask-Migrate (for database migrations)
  - Marshmallow (for serialization/deserialization)
  - Flask-JWT-Extended (for JWT authentication)

  Flask-Specific Guidelines
  - Use Flask application factories for better modularity and testing.
  - Organize routes using Flask Blueprints for better code organization.
  - Use Flask-RESTX for building RESTful APIs with class-based views.
  - Implement custom error handlers for different types of exceptions.
  - Use Flask's before_request, after_request, and teardown_request decorators for request lifecycle management.
  - Utilize Flask extensions for common functionalities (e.g., Flask-SQLAlchemy, Flask-Migrate).
  - Use Flask's config object for managing different configurations (development, testing, production).
  - Implement proper logging using Flask's app.logger.
  - Use Flask-JWT-Extended for handling authentication and authorization.

  Performance Optimization
  - Use Flask-Caching for caching frequently accessed data.
  - Implement database query optimization techniques (e.g., eager loading, indexing).
  - Use connection pooling for database connections.
  - Implement proper database session management.
  - Use background tasks for time-consuming operations (e.g., Celery with Flask).

  Key Conventions
  1. Use Flask's application context and request context appropriately.
  2. Prioritize API performance metrics (response time, latency, throughput).
  3. Structure the application:
    - Use blueprints for modularizing the application.
    - Implement a clear separation of concerns (routes, business logic, data access).
    - Use environment variables for configuration management.

  Database Interaction
  - Use Flask-SQLAlchemy for ORM operations.
  - Implement database migrations using Flask-Migrate.
  - Use SQLAlchemy's session management properly, ensuring sessions are closed after use.

  Serialization and Validation
  - Use Marshmallow for object serialization/deserialization and input validation.
  - Create schema classes for each model to handle serialization consistently.

  Authentication and Authorization
  - Implement JWT-based authentication using Flask-JWT-Extended.
  - Use decorators for protecting routes that require authentication.

  Testing
  - Write unit tests using pytest.
  - Use Flask's test client for integration testing.
  - Implement test fixtures for database and application setup.

  API Documentation
  - Use Flask-RESTX for Swagger/OpenAPI documentation.
  - Ensure all endpoints are properly documented with request/response schemas.

  Deployment
  - Use Gunicorn as WSGI HTTP Server.
  - Implement proper logging and monitoring in production.
  - Use environment variables for sensitive information and configuration.

  Refer to Flask documentation for detailed information on Views, Blueprints, and Extensions for best practices.

Never attempt to start the flask app, also not through run.py, just provide the code and instructions. I will run the app in the debugger myself.
